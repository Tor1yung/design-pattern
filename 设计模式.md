# 设计模式

###### 前言&总结：设计模式的奥妙就是让编译时转化为运行时，即让静态的(编译)多态推迟到动态的(运行)再体现，这样一来可以极大节约冗余量以及提高独立性

## 面性对象设计原则

### 依赖倒置原则DIP

##### 高层模块(稳定)不应该依赖于底层模块(不稳定)，二者应该依赖于抽象(稳定)；抽象(稳定)不应该依赖于实现细节(不稳定)，而应该反过来

###### 如果稳定依赖于不稳定，则由于不稳定模块自身变化会导致稳定模块也需要随之变换，这就使得稳定模块也变成不稳定。所以需要隔离不稳定模块，使用一个稳定的抽象，令二者都依赖于抽象。简单的看，就是编译时需不需要一来一些具体的，变化的实现内容

[参考案例](https://blog.csdn.net/zxcyblbq/article/details/121554175)

### 开放封闭原则OCP

##### **类模块应该是可扩展的，但是不可修改**

###### 对于需求的变更，我们应该进行新需求相关功能的扩展和添加，而不是对原有的结构进行更改，因为后者会牵一发而动全身。(开放扩展封闭修改)

### 单一职责原则SRP

##### 一个类应该只负责一项职责

###### 如果一个类包含了太多的职责，那么当其中的部分职责发生改变，可能会导致剩余职责发生故障。但是往往需要在遵守SRP和降低程序资源开销之间权衡，如为了遵守SRP我们会选择将一个类拆解成几个类分别执行不同职责，这样会导致内存开销变大。

[参考1](https://www.cnblogs.com/study-everyday/p/6709437.html)

[参考2](https://blog.csdn.net/u011852872/article/details/126134033)

### 里氏替换原则LSP

##### 子类必须能够替换他们的基类，且不可覆盖重写基类已经实现的方法

###### 里氏替换原则是对继承的一种约束，其保证子类一定具有父类的特性，可以进行扩展但是不可以对原有的特性进行修改

[参考1](https://blog.csdn.net/m0_37654408/article/details/105423543)

[参考2](https://blog.csdn.net/u011852872/article/details/126048726)

### 接口隔离原则ISP

##### 类(接口)应该小而完备，不要让客户程序依赖他们不需要的方法。

###### 类(接口)暴露(public)出去的应该是客户程序所需要的所有方法，少的不行，多的也不要，不然当多余的方法被修改时，客户程序也被迫需要进行原本不必要的修改

### 黒箱复用>白箱复用

##### 尽量不要使用类的继承(白箱复用)，而是使用黑箱复用(类对象的组合)

###### 白箱复用让类最大程度接收了基类的特性，甚至是一些不需要的东西，某种程度上破坏了封装性，而黑箱复用仅仅是在类内实例化并组合某些类的一些特性和方法，仅仅从黑箱中得到所需要的暴露的接口，耦合程度低。

### 封装变化点

##### 找出需求里的变化部分，通过将其封装，创建对象之间的分界层(稳定与变化)，对其中一侧(变化模块)进行修改，不会对稳定模块产生影响。

### 针对接口编程而不是针对实现编程

##### 在类内实现方法时(或者创建类对象时)，应该使用抽象的接口，而不是直接指定用什么类型的接口，这样一来，对于不同的客户程序，不必实现不同类型的实现方法
###### 如果直接使用特定的类，就定死了其未来的动态变化，使用抽象的接口类，未来需求发生变动，对接口进行扩展，则会更加灵活
[参考](https://blog.csdn.net/u013518556/article/details/79455638)



## 模式

### 模式方法(template method)

##### 定义操作中算法的骨架(即run里的内容)到基类里面，然后在骨架(run)中先放置一些变化的模块(虚函数)。然后这些变化的模块延迟到子类中进行实现

###### 这样便使得子类可以不改变(即可以复用)算法的结构(骨架run)而进行override里面的一些步骤(虚函数)，实现从传统的结构方式(main调用lib)转变为面向对象(lib调用main)   ps:这里main代表骨架run，lib代表子类

### 策略模式(strategy pattern)

##### 将算法策略进行独立封装(继承自抽象策略类)，并定义一个环境角色(接口类)提供给客户端

###### 消除if-else进行算法选择(这里if-else会因为情况的增多而需要加多，所以需要改成策略模式)

![image](https://github.com/Tor1yung/design-pattern/assets/127203005/0c241ad6-60fa-426f-982b-c43ec045e824)

[参考](https://www.cnblogs.com/xuwujing/p/9954263.html)



### 观察者模式(observer pattern)

###### 当我们希望某个对象状态发生改变，所有依赖对象(观察者)都得到通知，普通的方式是在被观察对象(稳定)里内嵌观察者对象(不稳定，因为通知方式可变化)，这样在编译时会造成“稳定 依赖 不稳定”，违背了DIP原则。

##### 将内嵌观察者对象更改为内嵌一个抽象接口，观察者对象继承接口并进行重写观察方式

###### 这样一来，稳定的被观察对象由于不存在具体的细节，编译是不依赖于观察者的而这是依赖于稳定的接口，实现了DIP



### 装饰器模式(decoration pattern)：用于动态地给对象添加新功能

###### 当我们想对类**附加**一些新的职责，如果每个职责组合就写一个类，所得到的排列组合呈阶乘数量

##### 原有的稳定的类保持不变，创建抽象装饰类(它和稳定类都继承于基类)，当有新的**附加**职责时，则继承抽象装饰类实现一个具体的装饰类。运行时将稳定类的实例化对象给装饰类进行构造得到装饰对象(或者装饰对象进行重复嵌套重复装饰)。

###### 这样一来，将编译时实现所有装配的排列组合，转变为在运行时按需求进行装配

![image](https://github.com/Tor1yung/design-pattern/assets/127203005/cbb0ef19-cece-4438-abdb-22570d69d6ea)

[参考](https://juejin.cn/post/6999268990971281439)

### 桥接模式(bridge pattern)



##### 两个模式都是为了解决子类过多问题, 但他们的诱因不同:
1.桥接模式对象自身有 沿着多个维度变化的趋势 , 本身不稳定;
2.装饰者模式对象自身非常稳定, 只是为了增加新功能/增强原功能。
###### 简单来说桥接就是多个维度都可能发生变化，对象的实例化需要多个维度之间的"组合"得到；而装饰器是依附在稳定对象上的(或者已被装饰过的稳定对象上)，对象的实例化是通过稳定对象的"扩展"得到。

### 工厂模式
#### 工厂模式
###### 为了避免在类内使用new进行创建，因为new后需要显式给出一个类
##### 通过创建一个接口(抽象工厂)，出现需要的类则进行子类(具体工厂)实现，在需要得到对象时，调用工厂生成返回一个对象。

